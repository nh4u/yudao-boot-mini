package cn.bitlinks.ems.module.power.service.standingbook.attribute;

import cn.bitlinks.ems.framework.common.util.object.BeanUtils;
import cn.bitlinks.ems.module.power.controller.admin.standingbook.attribute.vo.StandingbookAttributeRespVO;
import cn.bitlinks.ems.module.power.controller.admin.standingbook.attribute.vo.StandingbookAttributeSaveReqVO;
import cn.bitlinks.ems.module.power.dal.dataobject.standingbook.StandingbookDO;
import cn.bitlinks.ems.module.power.dal.dataobject.standingbook.attribute.StandingbookAttributeDO;
import cn.bitlinks.ems.module.power.dal.dataobject.standingbook.type.StandingbookTypeDO;
import cn.bitlinks.ems.module.power.dal.mysql.standingbook.StandingbookMapper;
import cn.bitlinks.ems.module.power.dal.mysql.standingbook.attribute.StandingbookAttributeMapper;
import cn.bitlinks.ems.module.power.enums.ApiConstants;
import cn.bitlinks.ems.module.power.service.standingbook.type.StandingbookTypeService;
import cn.bitlinks.ems.module.system.api.user.AdminUserApi;
import cn.bitlinks.ems.module.system.api.user.dto.AdminUserRespDTO;
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.collection.CollUtil;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.conditions.update.LambdaUpdateWrapper;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.annotation.Validated;

import javax.annotation.Resource;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static cn.bitlinks.ems.framework.common.exception.util.ServiceExceptionUtil.exception;
import static cn.bitlinks.ems.module.power.enums.ApiConstants.PARENT_ATTR_AUTO;
import static cn.bitlinks.ems.module.power.enums.ApiConstants.SYSTEM_CREATE;
import static cn.bitlinks.ems.module.power.enums.ErrorCodeConstants.*;
import static com.baomidou.mybatisplus.core.toolkit.StringPool.EMPTY;

/**
 * 台账属性 Service 实现类
 *
 * @author bitlinks
 */
@Service
@Validated
public class StandingbookAttributeServiceImpl implements StandingbookAttributeService {
    @Resource
    private StandingbookAttributeMapper standingbookAttributeMapper;

    @Resource
    private StandingbookMapper standingbookMapper;
    @Resource
    private AdminUserApi adminUserApi;
    @Resource
    @Lazy
    private StandingbookTypeService standingbookTypeService;


    @Transactional
    @Override
    public void update(StandingbookAttributeSaveReqVO updateReqVO) {
        // 更新
        StandingbookAttributeDO updateObj = BeanUtils.toBean(updateReqVO, StandingbookAttributeDO.class);
        LambdaUpdateWrapper<StandingbookAttributeDO> updateWrapper = new LambdaUpdateWrapper<>();
        updateWrapper.eq(StandingbookAttributeDO::getCode, updateObj.getCode()).eq(StandingbookAttributeDO::getStandingbookId, updateObj.getStandingbookId());
        standingbookAttributeMapper.update(updateObj, updateWrapper);
    }


    @Override
    public List<StandingbookAttributeDO> getStandingbookAttributeByTypeId(Long typeId) {
        return standingbookAttributeMapper.selectTypeId(typeId);
    }


    @Override
    public List<Long> getStandingbookIdByCondition(Map<String, List<String>> children, List<Long> sbIds) {
        return standingbookAttributeMapper.selectStandingbookIdByAttrCondition(children, sbIds);
    }


    @Override
    @Transactional
    public void saveMultiple(List<StandingbookAttributeSaveReqVO> createReqVOs) {
        if (CollUtil.isEmpty(createReqVOs)) {
            return;
        }
        List<StandingbookAttributeDO> optAttrList = BeanUtils.toBean(createReqVOs, StandingbookAttributeDO.class);
        // 剔除父节点自动生成属性，
        optAttrList.removeIf(upd -> ApiConstants.YES.equals(upd.getAutoGenerated()));
        if (CollUtil.isEmpty(optAttrList)) {
            return;
        }
        Long typeId = optAttrList.get(0).getTypeId();
        // 0：添加逻辑：如果分类下有了台账，则不允许修改和删除，只允许新增。。
        // 查询该台账分类下的分类们
        List<StandingbookTypeDO> typeList = standingbookTypeService.getStandingbookTypeNode();
        List<Long> subtreeIds = standingbookTypeService.getSubtreeIds(typeList, typeId);
        // 查询是否关联台账设备，关联后禁止修改和删除
        boolean isUpdateAndDeleteForbidden = false;
        List<StandingbookDO> associationSbList = standingbookMapper.selectList(new LambdaQueryWrapper<StandingbookDO>()
                .in(StandingbookDO::getTypeId, subtreeIds)
        );
        if (CollUtil.isNotEmpty(associationSbList)) {
            isUpdateAndDeleteForbidden = true;
        }
        // 找出当前属性列表
        List<StandingbookAttributeDO> rawAttrList = getStandingbookAttributeByTypeId(typeId);
        // 级联删除
        deleteAttrCascade(optAttrList, rawAttrList, isUpdateAndDeleteForbidden);


        // 将数据分为2组，分成 createList 和 updateList
        List<StandingbookAttributeDO> createList = optAttrList.stream()
                .filter(attribute -> attribute.getId() == null)
                .collect(Collectors.toList());
        List<StandingbookAttributeDO> updateList = optAttrList.stream()
                .filter(attribute -> attribute.getId() != null)
                .collect(Collectors.toList());
        // 进行级联创建操作
        createAttrCascade(createList, typeId, subtreeIds);
        // 进行级联修改操作
        updateAttrCascade(updateList, rawAttrList, isUpdateAndDeleteForbidden);

    }


    /**
     * 过滤掉未修改的分类属性
     *
     * @param updateList  分类属性列表
     * @param rawAttrList 原始分类属性列表
     */
    public static void filterModifiedAttributes(List<StandingbookAttributeDO> updateList, List<StandingbookAttributeDO> rawAttrList) {
        // 使用迭代器，避免 ConcurrentModificationException
        Iterator<StandingbookAttributeDO> iterator = updateList.iterator();
        while (iterator.hasNext()) {
            StandingbookAttributeDO updatedAttr = iterator.next();
            boolean modified = false; // 默认没有修改
            for (StandingbookAttributeDO rawAttr : rawAttrList) {
                if (updatedAttr.getId().equals(rawAttr.getId())) { // 找到匹配的 ID
                    // 比较属性 (简化写法)
                    if (!Objects.equals(updatedAttr.getName(), rawAttr.getName()) ||
                            !Objects.equals(updatedAttr.getFormat(), rawAttr.getFormat()) ||
                            !Objects.equals(updatedAttr.getSort(), rawAttr.getSort()) ||
                            !Objects.equals(updatedAttr.getIsRequired(), rawAttr.getIsRequired())) {
                        modified = true;  // 至少有一个属性被修改
                    }
                    break; // 找到匹配的 rawAttr，结束内层循环
                }
            }
            if (!modified) {
                iterator.remove(); // 如果没有修改，从 updateList 中移除
            }
        }
    }

    /**
     * 级联修改属性列表
     *
     * @param updateList                 修改属性列表
     * @param rawAttrList                原属性列表
     * @param isUpdateAndDeleteForbidden 是否禁止修改和删除
     */
    @Transactional
    public void updateAttrCascade(List<StandingbookAttributeDO> updateList, List<StandingbookAttributeDO> rawAttrList
            , boolean isUpdateAndDeleteForbidden) {
        if (CollUtil.isEmpty(updateList)) {
            return;
        }
        // 0. 修改列表中需要剔除掉实际没有修改的数据，需要与当前节点列表做对比，
        filterModifiedAttributes(updateList, rawAttrList);
        if (CollUtil.isEmpty(updateList)) {
            return;
        }
        if (isUpdateAndDeleteForbidden) {
            throw exception(STANDINGBOOK_EXIST_NOT_SUPPORT_UPD_DEL);
        }
        // 1. 修改操作节点属性
        standingbookAttributeMapper.updateBatch(updateList);
        // 2. 修改影响节点属性
        Set<Long> updIds = updateList.stream()
                .map(StandingbookAttributeDO::getId)
                .collect(Collectors.toSet());
        // 2.1 获取影响到的节点属性
        List<StandingbookAttributeDO> attrList = standingbookAttributeMapper.selectList(new LambdaQueryWrapper<StandingbookAttributeDO>()
                .in(StandingbookAttributeDO::getRawAttrId, updIds));
        // 2.2 根据 rawAttrId 分组
        Map<Long, List<StandingbookAttributeDO>> groupedByRawAttrId = attrList.stream()
                .collect(Collectors.groupingBy(StandingbookAttributeDO::getRawAttrId));
        groupedByRawAttrId.entrySet().removeIf(entry -> CollUtil.isEmpty(entry.getValue()));

        // 2.3 级联修改操作节点的属性，组成List
        List<StandingbookAttributeDO> cascadeAttrList = new ArrayList<>();
        groupedByRawAttrId.forEach((rawAttrId, updAttrList) -> {
            // 需要处理修改的属性列表（同一属性id对应的关联属性列表）
            List<StandingbookAttributeDO> optUpdAttrList = BeanUtil.copyToList(updAttrList, StandingbookAttributeDO.class);
            // 变动修改的属性
            Optional<StandingbookAttributeDO> foundAttribute = updateList.stream().filter(updAttr -> updAttr.getId().equals(rawAttrId)).findFirst();
            if (foundAttribute.isPresent()) {
                StandingbookAttributeDO updAttribute = foundAttribute.get();
                optUpdAttrList.forEach(attribute -> {
                    //如果类型改变的话，属性值要清空(针对台账的属性列表)
                    if (!attribute.getFormat().equals(updAttribute.getFormat())) {
                        attribute.setValue(EMPTY);
                    }
                    attribute.setName(updAttribute.getName())
                            .setIsRequired(updAttribute.getIsRequired())
                            .setSort(updAttribute.getSort())
                            .setFormat(updAttribute.getFormat());

                });
                cascadeAttrList.addAll(optUpdAttrList);
            }
        });
        if (CollUtil.isEmpty(cascadeAttrList)) {
            return;
        }
        // 2.4 执行修改级联节点属性操作
        standingbookAttributeMapper.updateBatch(cascadeAttrList);
    }

    /**
     * 级联新增属性列表（分类编码重复）
     *
     * @param createList 新增属性列表
     * @param typeId     台账类型id
     */
    @Transactional
    public void createAttrCascade(List<StandingbookAttributeDO> createList, Long typeId, List<Long> subtreeIds) {
        if (CollUtil.isEmpty(createList)) {
            return;
        }

        // 1. 新增当前分类的属性
        standingbookAttributeMapper.insertBatch(createList);
        // 1.1 新增当前分类台账的属性
        List<StandingbookDO> sbList = standingbookMapper.selectList(new LambdaQueryWrapper<StandingbookDO>()
                .in(StandingbookDO::getTypeId, typeId)
        );
        List<StandingbookAttributeDO> attrList = new ArrayList<>();
        if (CollUtil.isNotEmpty(sbList)) {
            sbList.forEach(sb -> {
                createList.forEach(attribute -> {
                    StandingbookAttributeDO attributeCopy = BeanUtil.copyProperties(attribute, StandingbookAttributeDO.class);
                    attributeCopy.setDescription(PARENT_ATTR_AUTO)
                            .setAutoGenerated(ApiConstants.YES)
                            .setTypeId(typeId)
                            .setStandingbookId(sb.getId())
                            .setId(null)
                            .setRawAttrId(attribute.getId());
                    attrList.add(attributeCopy);
                });
            });
        }
        standingbookAttributeMapper.insertBatch(attrList);
        // 2. 获取所有typeId tree，查询所有的子级节点的typeId
        subtreeIds.removeIf(typeId::equals);
        if (CollUtil.isEmpty(subtreeIds)) {
            return;
        }
        // 3. 校验编码是否与子孙分类编码重复(新增逻辑，后台校验编码唯一)
        Set<String> codeSet = createList.stream()
                .map(StandingbookAttributeDO::getCode)
                .collect(Collectors.toSet());
        List<StandingbookAttributeDO> childrenAttrList = standingbookAttributeMapper.selectList(new LambdaQueryWrapper<StandingbookAttributeDO>()
                .in(StandingbookAttributeDO::getTypeId, subtreeIds)
                .eq(StandingbookAttributeDO::getAutoGenerated, ApiConstants.NO));
        Set<String> childrenCodeSet = childrenAttrList.stream()
                .map(StandingbookAttributeDO::getCode)
                .collect(Collectors.toSet());
        codeSet.retainAll(childrenCodeSet);
        // 新增编码存在于子级手动新增的编码中
        if (!codeSet.isEmpty()) {
            throw exception(STANDINGBOOK_CODE_REPEAT_CHILDREN);
        }

        // 3.0.1 查询所有级联的typeId关联的台账Id列表
        List<StandingbookDO> cascadeTypeIdList = standingbookMapper.selectList(new LambdaQueryWrapper<StandingbookDO>()
                .in(StandingbookDO::getTypeId, subtreeIds)
        );
        Map<Long, List<StandingbookDO>> typeIdMapSb = new HashMap<>();
        if (CollUtil.isNotEmpty(cascadeTypeIdList)) {
            // 按照typeId-台账分组
            typeIdMapSb = cascadeTypeIdList.stream()
                    .collect(Collectors.groupingBy(StandingbookDO::getTypeId));
        }
        // 3. 新增所有级联的typeId的属性
        List<StandingbookAttributeDO> cascadeAttrList = new ArrayList<>();
        Map<Long, List<StandingbookDO>> finalTypeIdMapSb = typeIdMapSb;
        subtreeIds.forEach(subId -> {
            // 处理新增的属性列表
            List<StandingbookAttributeDO> subAttrList = new ArrayList<>();
            createList.forEach(attribute -> {
                StandingbookAttributeDO attributeCopy = BeanUtil.copyProperties(attribute, StandingbookAttributeDO.class);
                attributeCopy.setDescription(PARENT_ATTR_AUTO)
                        .setAutoGenerated(ApiConstants.YES)
                        .setTypeId(subId)
                        .setId(null)
                        .setRawAttrId(attribute.getId());
                subAttrList.add(attributeCopy);
            });
            // 通过台账分类去关联台账新增属性列表
            if (CollUtil.isNotEmpty(finalTypeIdMapSb) && finalTypeIdMapSb.containsKey(subId)) {
                List<StandingbookDO> typeSbList = finalTypeIdMapSb.get(subId);
                typeSbList.forEach(sb -> {
                    createList.forEach(attribute -> {
                        StandingbookAttributeDO attributeCopy = BeanUtil.copyProperties(attribute, StandingbookAttributeDO.class);
                        attributeCopy.setDescription(PARENT_ATTR_AUTO)
                                .setAutoGenerated(ApiConstants.YES)
                                .setTypeId(subId)
                                .setStandingbookId(sb.getId())
                                .setId(null)
                                .setRawAttrId(attribute.getId());
                        subAttrList.add(attributeCopy);
                    });
                });
            }
            cascadeAttrList.addAll(subAttrList);
        });

        // 4.执行新增操作
        standingbookAttributeMapper.insertBatch(cascadeAttrList);

    }

    /**
     * 级联删除属性列表
     *
     * @param optAttrList                新属性列表
     * @param rawAttrList                原属性列表
     * @param isUpdateAndDeleteForbidden 是否禁止更新和删除
     */
    @Transactional(rollbackFor = Exception.class)
    public void deleteAttrCascade(List<StandingbookAttributeDO> optAttrList,
                                  List<StandingbookAttributeDO> rawAttrList, boolean isUpdateAndDeleteForbidden) {
        if (CollUtil.isEmpty(rawAttrList)) {
            return;
        }
        // 找出被删除的属性id集合
        Set<Long> deleteIds = rawAttrList.stream()
                .map(StandingbookAttributeDO::getId)
                .filter(id -> optAttrList.stream().noneMatch(reqVO -> id.equals(reqVO.getId())))
                .collect(Collectors.toSet());
        if (CollUtil.isEmpty(deleteIds)) {
            return;
        }
        if (isUpdateAndDeleteForbidden) {
            throw exception(STANDINGBOOK_EXIST_NOT_SUPPORT_UPD_DEL);
        }
        // 删除操作节点属性
        standingbookAttributeMapper.deleteByIds(deleteIds);
        // 删除关联的节点属性
        standingbookAttributeMapper.delete(new LambdaQueryWrapper<StandingbookAttributeDO>()
                .in(StandingbookAttributeDO::getRawAttrId, deleteIds));
    }


    @Override
    public List<StandingbookAttributeRespVO> getByTypeId(Long typeId) {
        List<StandingbookAttributeDO> standingbookAttributes = getStandingbookAttributeByTypeId(typeId);
        List<StandingbookAttributeRespVO> bean = BeanUtils.toBean(standingbookAttributes, StandingbookAttributeRespVO.class);
        //查询所有分类
        Map<Long, StandingbookTypeDO> allTypeMap = standingbookTypeService.getStandingbookTypeIdMap(null);
        // 查询所有用户
        Map<Long, AdminUserRespDTO> allUserMap = adminUserApi.getAllUserMap();
        IntStream.range(0, bean.size()).forEach(i -> {
            String creatorId = standingbookAttributes.get(i).getCreator();

            // 获取归属节点名称
            StandingbookTypeDO type = allTypeMap.get(bean.get(i).getNodeId());
            if (type != null) {
                bean.get(i).setNode(type.getName());
            }
            if (ApiConstants.YES.equals(bean.get(i).getDisplayFlag())) {
                bean.get(i).setCreateByName(SYSTEM_CREATE);
            } else {
                // 获取创建人名称
                AdminUserRespDTO user = allUserMap.get(Long.valueOf(creatorId));
                if (user != null) {
                    bean.get(i).setCreateByName(user.getNickname());
                }
            }

        });
        return bean;

    }


    @Override
    public Map<Long, List<StandingbookAttributeDO>> getAttributesBySbIds(List<Long> sbIds) {
        List<StandingbookAttributeDO> attrs = standingbookAttributeMapper.selectList(new LambdaQueryWrapper<StandingbookAttributeDO>().in(StandingbookAttributeDO::getStandingbookId, sbIds));

        if (CollUtil.isEmpty(attrs)) {
            throw exception(STANDINGBOOK_NO_ATTR);
        }

        return attrs.stream()
                .collect(Collectors.groupingBy(StandingbookAttributeDO::getStandingbookId));
    }


}
