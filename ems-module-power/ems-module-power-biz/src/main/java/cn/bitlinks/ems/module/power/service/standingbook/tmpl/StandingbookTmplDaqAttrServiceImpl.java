package cn.bitlinks.ems.module.power.service.standingbook.tmpl;

import cn.bitlinks.ems.framework.common.util.object.BeanUtils;
import cn.bitlinks.ems.framework.mybatis.core.query.LambdaQueryWrapperX;
import cn.bitlinks.ems.framework.mybatis.core.query.MPJLambdaWrapperX;
import cn.bitlinks.ems.module.power.controller.admin.standingbook.tmpl.vo.StandingbookTmplDaqAttrRespVO;
import cn.bitlinks.ems.module.power.controller.admin.standingbook.tmpl.vo.StandingbookTmplDaqAttrSaveReqVO;
import cn.bitlinks.ems.module.power.controller.admin.standingbook.tmpl.vo.StandingbookTmplDaqAttrSbRespVO;
import cn.bitlinks.ems.module.power.dal.dataobject.energyparameters.EnergyParametersDO;
import cn.bitlinks.ems.module.power.dal.dataobject.standingbook.StandingbookDO;
import cn.bitlinks.ems.module.power.dal.dataobject.standingbook.tmpl.StandingbookTmplDaqAttrDO;
import cn.bitlinks.ems.module.power.dal.dataobject.standingbook.type.StandingbookTypeDO;
import cn.bitlinks.ems.module.power.dal.mysql.standingbook.StandingbookMapper;
import cn.bitlinks.ems.module.power.dal.mysql.standingbook.templ.StandingbookTmplDaqAttrMapper;
import cn.bitlinks.ems.module.power.enums.ApiConstants;
import cn.bitlinks.ems.module.power.service.standingbook.type.StandingbookTypeService;
import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.collection.CollUtil;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.annotation.Validated;

import javax.annotation.Resource;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static cn.bitlinks.ems.framework.common.exception.util.ServiceExceptionUtil.exception;
import static cn.bitlinks.ems.module.power.enums.ApiConstants.SQL_SB_ID;
import static cn.bitlinks.ems.module.power.enums.ErrorCodeConstants.STANDINGBOOK_CODE_REPEAT_CHILDREN;
import static cn.bitlinks.ems.module.power.enums.ErrorCodeConstants.STANDINGBOOK_EXIST_NOT_SUPPORT_UPD_DEL;

/**
 * 台账模板数采属性 Service 实现类
 *
 * @author bitlinks
 */
@Service
@Validated
@Slf4j
public class StandingbookTmplDaqAttrServiceImpl implements StandingbookTmplDaqAttrService {
    @Resource
    private StandingbookTmplDaqAttrMapper standingbookTmplDaqAttrMapper;

    @Resource
    @Lazy
    private StandingbookTypeService standingbookTypeService;

    @Resource
    private StandingbookMapper standingbookMapper;

    /**
     * 获取分类数采属性
     *
     * @param typeId     分类id
     * @param energyFlag 是否能源参数
     * @return 数采属性列表
     */
    private List<StandingbookTmplDaqAttrDO> getSbTmplDaqAttrByTypeId(Long typeId, Boolean energyFlag) {
        return standingbookTmplDaqAttrMapper.selectList(new LambdaQueryWrapper<StandingbookTmplDaqAttrDO>()
                .eq(StandingbookTmplDaqAttrDO::getTypeId, typeId)
                .eq(StandingbookTmplDaqAttrDO::getEnergyFlag, energyFlag));
    }


    @Override
    @Transactional
    public void saveMultiple(List<StandingbookTmplDaqAttrSaveReqVO> saveReqVOList) {
        if (CollUtil.isEmpty(saveReqVOList)) {
            return;
        }
        List<StandingbookTmplDaqAttrDO> optAttrList = BeanUtils.toBean(saveReqVOList, StandingbookTmplDaqAttrDO.class);
        // 剔除父节点自动生成属性，
        optAttrList.removeIf(upd -> ApiConstants.YES.equals(upd.getAutoGenerated()));
        if (CollUtil.isEmpty(optAttrList)) {
            return;
        }
        Long typeId = optAttrList.get(0).getTypeId();
        // 0：添加逻辑：如果分类下有了台账，则不允许修改和删除，只允许新增。。
        // 查询该台账分类下的分类们
        List<StandingbookTypeDO> typeList = standingbookTypeService.getStandingbookTypeNode();
        List<Long> subtreeIds = standingbookTypeService.getSubtreeIds(typeList, typeId);
        // 查询是否关联台账设备，关联后禁止修改和删除
        boolean isUpdateAndDeleteForbidden = false;
        List<StandingbookDO> associationSbList = standingbookMapper.selectList(new LambdaQueryWrapper<StandingbookDO>()
                .in(StandingbookDO::getTypeId, subtreeIds)
        );
        if (CollUtil.isNotEmpty(associationSbList)) {
            isUpdateAndDeleteForbidden = true;
        }
        Boolean energyFlag = optAttrList.get(0).getEnergyFlag();
        // 找出当前属性列表
        List<StandingbookTmplDaqAttrDO> rawAttrList = getSbTmplDaqAttrByTypeId(typeId, energyFlag);
        // 级联删除
        deleteAttrCascade(optAttrList, rawAttrList, isUpdateAndDeleteForbidden);

        // 将数据分为2组，分成 createList 和 updateList
        List<StandingbookTmplDaqAttrDO> createList = optAttrList.stream()
                .filter(attribute -> attribute.getId() == null)
                .collect(Collectors.toList());
        List<StandingbookTmplDaqAttrDO> updateList = optAttrList.stream()
                .filter(attribute -> attribute.getId() != null)
                .collect(Collectors.toList());
        // 进行级联创建操作
        subtreeIds.removeIf(typeId::equals);
        createAttrCascade(createList, subtreeIds, energyFlag);
        // 进行级联修改操作
        updateAttrCascade(updateList, rawAttrList, isUpdateAndDeleteForbidden);

    }


    /**
     * 过滤掉未修改的分类属性
     *
     * @param updateList  分类属性列表
     * @param rawAttrList 原始分类属性列表
     */
    public static void filterModifiedDaqAttributes(List<StandingbookTmplDaqAttrDO> updateList,
                                                   List<StandingbookTmplDaqAttrDO> rawAttrList) {
        updateList.removeIf(updatedAttr -> rawAttrList.stream()
                .anyMatch(rawAttr -> updatedAttr.getId().equals(rawAttr.getId()) &&
                        Objects.equals(updatedAttr.getParameter(), rawAttr.getParameter()) &&
                        Objects.equals(updatedAttr.getCode(), rawAttr.getCode()) &&
                        Objects.equals(updatedAttr.getDataType(), rawAttr.getDataType()) &&
                        Objects.equals(updatedAttr.getDataFeature(), rawAttr.getDataFeature()) &&
                        Objects.equals(updatedAttr.getSort(), rawAttr.getSort()) &&
                        Objects.equals(updatedAttr.getUnit(), rawAttr.getUnit())));

    }

    /**
     * 级联修改属性列表
     *
     * @param updateList                 修改属性列表
     * @param rawAttrList                原属性列表
     * @param isUpdateAndDeleteForbidden 是否禁止修改和删除
     */
    @Transactional
    public void updateAttrCascade(List<StandingbookTmplDaqAttrDO> updateList,
                                  List<StandingbookTmplDaqAttrDO> rawAttrList, boolean isUpdateAndDeleteForbidden) {
        if (CollUtil.isEmpty(updateList)) {
            return;
        }
        // 0. 修改列表中需要剔除掉实际没有修改的数据，需要与当前节点列表做对比，
        filterModifiedDaqAttributes(updateList, rawAttrList);
        if (CollUtil.isEmpty(updateList)) {
            return;
        }
        if (isUpdateAndDeleteForbidden) {
            throw exception(STANDINGBOOK_EXIST_NOT_SUPPORT_UPD_DEL);
        }

        // 1. 修改操作节点属性
        standingbookTmplDaqAttrMapper.updateBatch(updateList);
        // 2. 修改影响节点属性
        Set<Long> updIds = updateList.stream()
                .map(StandingbookTmplDaqAttrDO::getId)
                .collect(Collectors.toSet());
        // 2.1 获取影响到的节点属性
        List<StandingbookTmplDaqAttrDO> attrList =
                standingbookTmplDaqAttrMapper.selectList(new LambdaQueryWrapper<StandingbookTmplDaqAttrDO>()
                        .in(StandingbookTmplDaqAttrDO::getRawAttrId, updIds));

        // 2.2 根据 rawAttrId 分组
        Map<Long, List<StandingbookTmplDaqAttrDO>> groupedByRawAttrId = attrList.stream()
                .collect(Collectors.groupingBy(StandingbookTmplDaqAttrDO::getRawAttrId));
        groupedByRawAttrId.entrySet().removeIf(entry -> CollUtil.isEmpty(entry.getValue()));

        // 2.3 级联修改操作节点的属性，组成List
        List<StandingbookTmplDaqAttrDO> cascadeAttrList = new ArrayList<>();
        groupedByRawAttrId.forEach((rawAttrId, updAttrList) -> {
            // 需要处理修改的属性列表（同一属性id对应的关联属性列表）
            List<StandingbookTmplDaqAttrDO> optUpdAttrList = BeanUtil.copyToList(updAttrList, StandingbookTmplDaqAttrDO.class);
            // 变动修改的属性
            Optional<StandingbookTmplDaqAttrDO> foundAttribute = updateList.stream().filter(updAttr -> updAttr.getId().equals(rawAttrId)).findFirst();
            if (foundAttribute.isPresent()) {
                StandingbookTmplDaqAttrDO updAttribute = foundAttribute.get();
                optUpdAttrList.forEach(attribute -> {
                    attribute.setParameter(updAttribute.getParameter())
                            .setCode(updAttribute.getCode())
                            .setUnit(updAttribute.getUnit())
                            .setSort(updAttribute.getSort())
                            .setDataType(updAttribute.getDataType())
                            .setDataFeature(updAttribute.getDataFeature());

                });
                cascadeAttrList.addAll(optUpdAttrList);
            }
        });
        if (CollUtil.isEmpty(cascadeAttrList)) {
            return;
        }
        // 2.4 执行修改级联节点属性操作
        standingbookTmplDaqAttrMapper.updateBatch(cascadeAttrList);
    }

    /**
     * 级联新增属性列表（分类编码重复）
     *
     * @param createList 新增属性列表
     * @param subtreeIds 台账类型子级节点
     * @param energyFlag 是否能源
     */
    @Transactional
    public void createAttrCascade(List<StandingbookTmplDaqAttrDO> createList, List<Long> subtreeIds,
                                  Boolean energyFlag) {
        if (CollUtil.isEmpty(createList)) {
            return;
        }
        // 1. 新增当前分类的属性
        standingbookTmplDaqAttrMapper.insertBatch(createList);

        // 2. 获取所有typeId tree，查询所有的子级节点的typeId

        if (CollUtil.isEmpty(subtreeIds)) {
            return;
        }
        // 3. 校验编码是否与子孙分类编码重复
        // (只需要判断自定义数采是否重复即可，能源数采参数在能源处做校验即可))
        if (!energyFlag) {
            Set<String> codeSet = createList.stream()
                    .map(StandingbookTmplDaqAttrDO::getCode)
                    .collect(Collectors.toSet());
            List<StandingbookTmplDaqAttrDO> childrenAttrList = standingbookTmplDaqAttrMapper.selectList(new LambdaQueryWrapper<StandingbookTmplDaqAttrDO>()
                    .in(StandingbookTmplDaqAttrDO::getTypeId, subtreeIds)
                    .eq(StandingbookTmplDaqAttrDO::getEnergyFlag, false)
                    .eq(StandingbookTmplDaqAttrDO::getAutoGenerated, ApiConstants.NO));
            Set<String> childrenCodeSet = childrenAttrList.stream()
                    .map(StandingbookTmplDaqAttrDO::getCode)
                    .collect(Collectors.toSet());
            codeSet.retainAll(childrenCodeSet);
            // 新增编码存在于子级手动新增的编码中
            if (!codeSet.isEmpty()) {
                throw exception(STANDINGBOOK_CODE_REPEAT_CHILDREN);
            }
        }

        // 3. 新增所有级联的typeId的属性
        List<StandingbookTmplDaqAttrDO> cascadeAttrList = new ArrayList<>();
        subtreeIds.forEach(subId -> {
            // 处理新增的属性列表
            List<StandingbookTmplDaqAttrDO> subAttrList = new ArrayList<>();
            createList.forEach(attribute -> {
                StandingbookTmplDaqAttrDO attributeCopy = BeanUtil.copyProperties(attribute, StandingbookTmplDaqAttrDO.class);
                attributeCopy.setAutoGenerated(ApiConstants.YES)
                        .setTypeId(subId)
                        .setId(null)
                        .setRawAttrId(attribute.getId());
                subAttrList.add(attributeCopy);
            });

            cascadeAttrList.addAll(subAttrList);
        });
        // 4.执行新增操作
        standingbookTmplDaqAttrMapper.insertBatch(cascadeAttrList);
    }


    /**
     * 级联删除属性列表
     *
     * @param optAttrList                新属性列表
     * @param rawAttrList                原属性列表
     * @param isUpdateAndDeleteForbidden 是否禁止更新和删除
     */
    @Transactional(rollbackFor = Exception.class)
    public void deleteAttrCascade(List<StandingbookTmplDaqAttrDO> optAttrList,
                                  List<StandingbookTmplDaqAttrDO> rawAttrList, boolean isUpdateAndDeleteForbidden) {
        if (CollUtil.isEmpty(rawAttrList)) {
            return;
        }
        // 找出被删除的属性id集合
        Set<Long> deleteIds = rawAttrList.stream()
                .map(StandingbookTmplDaqAttrDO::getId)
                .filter(id -> optAttrList.stream().noneMatch(reqVO -> id.equals(reqVO.getId())))
                .collect(Collectors.toSet());
        if (CollUtil.isEmpty(deleteIds)) {
            return;
        }
        if (isUpdateAndDeleteForbidden) {
            throw exception(STANDINGBOOK_EXIST_NOT_SUPPORT_UPD_DEL);
        }
        // 删除操作节点属性
        standingbookTmplDaqAttrMapper.deleteByIds(deleteIds);
        // 删除关联的节点属性
        standingbookTmplDaqAttrMapper.delete(new LambdaQueryWrapper<StandingbookTmplDaqAttrDO>()
                .in(StandingbookTmplDaqAttrDO::getRawAttrId, deleteIds));
    }


    @Override
    public List<StandingbookTmplDaqAttrRespVO> getByTypeIdAndEnergyFlag(Long typeId, Boolean energyFlag) {
        List<StandingbookTmplDaqAttrDO> standingbookAttributes = getSbTmplDaqAttrByTypeId(typeId, energyFlag);
        List<StandingbookTmplDaqAttrRespVO> bean = BeanUtils.toBean(standingbookAttributes, StandingbookTmplDaqAttrRespVO.class);
        // 查询所有分类
        Map<Long, StandingbookTypeDO> allTypeMap = standingbookTypeService.getStandingbookTypeIdMap(null);
        // 查询所有用户
        IntStream.range(0, bean.size()).forEach(i -> {

            // 获取归属节点名称
            StandingbookTypeDO type = allTypeMap.get(bean.get(i).getNodeId());
            if (type != null) {
                bean.get(i).setNode(type.getName());
            }

        });
        return bean;

    }

    @Override
    @Transactional
    public void cascadeAddDaqAttrByEnergyParams(Long energyId, List<EnergyParametersDO> energyParams) {
        if (CollUtil.isEmpty(energyParams)) {
            return;
        }
        // 根据能源查询绑定的台账分类(原始节点)
        List<Long> typeIds =
                standingbookTmplDaqAttrMapper.selectSbTypeIdsByEnergyId(energyId);
        if (CollUtil.isEmpty(typeIds)) {
            return;
        }
        List<StandingbookTmplDaqAttrSaveReqVO> saveReqVOList = BeanUtils.toBean(energyParams, StandingbookTmplDaqAttrSaveReqVO.class);
        // 查询所有台账分类
        List<StandingbookTypeDO> typeList = standingbookTypeService.getStandingbookTypeNode();

        // 新增能源数采参数
        typeIds.forEach(typeId -> {
            List<StandingbookTmplDaqAttrDO> createList = BeanUtils.toBean(saveReqVOList, StandingbookTmplDaqAttrDO.class);
            createList.forEach(attribute -> {
                attribute.setId(null);
                attribute.setEnergyId(energyId);
                attribute.setEnergyFlag(true);
                attribute.setTypeId(typeId);
                attribute.setNodeId(typeId);
            });
            // 该台账分类影响的所有分类节点
            List<Long> subtreeIds = standingbookTypeService.getSubtreeIds(typeList, typeId);
            //组装
            subtreeIds.removeIf(typeId::equals);
            createAttrCascade(createList, subtreeIds, true);
        });
    }

    @Override
    public boolean isAssociationWithEnergyId(Long energyId) {
        List<StandingbookTmplDaqAttrDO> daqAttrDOS =
                standingbookTmplDaqAttrMapper.selectList(new LambdaQueryWrapper<StandingbookTmplDaqAttrDO>()
                        .eq(StandingbookTmplDaqAttrDO::getEnergyFlag, true)
                        .eq(StandingbookTmplDaqAttrDO::getEnergyId, energyId)
                );
        return CollUtil.isNotEmpty(daqAttrDOS);
    }

    @Override
    public StandingbookTmplDaqAttrRespVO getUsageAttrBySbId(Long id) {
        // 查询台账分类
        StandingbookDO standingbookDO = standingbookMapper.selectById(id);
        Long typeId = standingbookDO.getTypeId();
        // 根据分类查询分类的数采属性
        StandingbookTmplDaqAttrDO daqAttrDO =
                standingbookTmplDaqAttrMapper.selectOne(new LambdaQueryWrapper<StandingbookTmplDaqAttrDO>()
                        .eq(StandingbookTmplDaqAttrDO::getEnergyFlag, true)
                        .eq(StandingbookTmplDaqAttrDO::getUsage, 1)
                        .eq(StandingbookTmplDaqAttrDO::getTypeId, typeId)
                );
        if (daqAttrDO == null) {
            return null;
        }
        return BeanUtils.toBean(daqAttrDO, StandingbookTmplDaqAttrRespVO.class);
    }

    @Override
    public Map<Long, List<StandingbookTmplDaqAttrDO>> getDaqAttrsByTypeIds(List<Long> typeIds) {
        List<StandingbookTmplDaqAttrDO> standingbookTmplDaqAttrDOS =
                standingbookTmplDaqAttrMapper.selectList(new LambdaQueryWrapperX<StandingbookTmplDaqAttrDO>()
                        .eq(StandingbookTmplDaqAttrDO::getStatus, true)
                        .inIfPresent(StandingbookTmplDaqAttrDO::getTypeId, typeIds)
                        .orderByDesc(StandingbookTmplDaqAttrDO::getSort));

        if (CollUtil.isEmpty(standingbookTmplDaqAttrDOS)) {
            return Collections.emptyMap();
        }

        return standingbookTmplDaqAttrDOS.stream()
                .collect(Collectors.groupingBy(StandingbookTmplDaqAttrDO::getTypeId));
    }

    @Override
    public Map<Long, List<StandingbookTmplDaqAttrDO>> getDaqAttrsBySbIds(List<Long> sbIds) {

        MPJLambdaWrapperX<StandingbookTmplDaqAttrDO> query = new MPJLambdaWrapperX<StandingbookTmplDaqAttrDO>()
                .selectAll(StandingbookTmplDaqAttrDO.class)
                .selectAs(StandingbookDO::getId, SQL_SB_ID)
                .eq(StandingbookTmplDaqAttrDO::getStatus, true)
                .orderByDesc(StandingbookTmplDaqAttrDO::getSort);

        query.rightJoin(StandingbookDO.class, StandingbookDO::getTypeId, StandingbookTmplDaqAttrDO::getTypeId)
                .in(StandingbookDO::getId, sbIds);

        List<StandingbookTmplDaqAttrSbRespVO> standingbookTmplDaqAttrDOS =
                standingbookTmplDaqAttrMapper.selectJoinList(StandingbookTmplDaqAttrSbRespVO.class, query);
        if (CollUtil.isEmpty(standingbookTmplDaqAttrDOS)) {
            return Collections.emptyMap();
        }
        Map<Long, List<StandingbookTmplDaqAttrSbRespVO>> originalMap = standingbookTmplDaqAttrDOS.stream().collect(Collectors.groupingBy(StandingbookTmplDaqAttrSbRespVO::getSbId));

        return originalMap.entrySet().stream()
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        entry -> entry.getValue().stream()
                                .map(respVO -> BeanUtil.toBean(respVO, StandingbookTmplDaqAttrDO.class))
                                .collect(Collectors.toList())
                ));


    }


}
